// Code generated by hertz generator.

package money

import (
	"context"
	"fmt"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/jhue/misgo/biz"
	"github.com/jhue/misgo/biz/model/base"
	money "github.com/jhue/misgo/biz/model/money"
	"github.com/jhue/misgo/biz/request"
	"github.com/jhue/misgo/db"
	moneyM "github.com/jhue/misgo/db/model/money"
	"github.com/jhue/misgo/db/model/user"
	"github.com/jhue/misgo/internal/mislog"
	"gorm.io/gorm"
	"math"
	"strings"
	"time"
)

func TransactionSearch(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	_, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	c.HTML(200, "money.html", nil)
}

// TransactionPut .
// @router api/money [PUT]
func TransactionPut(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	if req.OneTransaction == nil {
		bizCtx.ParmaError(money.ErrTransactionError)
		return
	}
	req.OneTransaction.Filter()
	err = req.OneTransaction.Validation()
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}

	d := db.Get()
	entry := moneyM.Transaction{
		UserID:   u.ID,
		Type:     req.OneTransaction.Type,
		Category: req.OneTransaction.Category,
		Amount:   float64(req.OneTransaction.Amount),
		Note:     req.OneTransaction.Note,
		Time:     time.Unix(req.OneTransaction.Time, 0),
	}
	err = d.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&entry).Error; err != nil {
			return err
		}
		personal := moneyM.TransactionPersonal{}
		if err := personal.Update(tx, entry); err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		bizCtx.DBError(err)
		return
	}

	bizCtx.Success()
	mislog.DefaultLogger.Infof("Money Success [Name] %s [Transaction] %s \n", u.Name, entry.String())
}

// TransactionGet .
// @router api/money [POST]
func TransactionGet(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionGetReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	config := biz.GetBizConfig().MoneyConfig

	d := db.Get()
	if req.Count > config.MaxGetCount {
		req.Count = config.MaxGetCount
	}

	startDate, endDate, _ := req.GetDateRange()
	if startDate.After(endDate) {
		bizCtx.ParmaError(money.ErrStartTimeBeforeEndTime)
		return
	}
	var b []*moneyM.Transaction
	if req.Count >= 0 {
		b = make([]*moneyM.Transaction, 0, req.Count)
	}

	var query string
	if req.Condition != "" {
		query = fmt.Sprintf("user_id = ?  AND (time >= ? AND time <= ?) AND %s", req.Condition)
	} else {
		query = fmt.Sprintf("user_id = ? AND (time >= ? AND time <= ?)")
	}

	res := d.Where(query, u.ID, startDate, endDate).Order(req.Order).Offset(int(req.Start)).Limit(int(req.Count)).Find(&b)
	if res.Error != nil {
		bizCtx.DBError(res.Error)
		return
	}

	resp := money.TransactionResp{
		Transactions: make([]*money.Transaction, 0, len(b)),
	}

	for _, transaction := range b {
		resp.Transactions = append(resp.Transactions, &money.Transaction{
			ID:       int64(transaction.ID),
			Type:     transaction.Type,
			Category: transaction.Category,
			Amount:   float32(transaction.Amount),
			Note:     transaction.Note,
			Time:     transaction.Time.Unix(),
		})
	}

	bizCtx.Response(&resp)
	mislog.DefaultLogger.Infof("MoneyGet Success [Name] %s [Returns] %d\n", u.Name, len(b))
}

// TransactionGetView .
// @router api/money/view [POST]
func TransactionGetView(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionGetReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	config := biz.GetBizConfig().MoneyConfig

	d := db.Get()
	if req.Count > config.MaxGetCount {
		req.Count = config.MaxGetCount
	}
	startDate, endDate, _ := req.GetDateRange()
	if startDate.After(endDate) {
		bizCtx.ParmaError(money.ErrStartTimeBeforeEndTime)
		return
	}

	var query string
	if req.Condition != "" {
		query = fmt.Sprintf("user_id = ? AND (time >= ? AND time <= ?) AND type=? AND %s ", req.Condition)
	} else {
		query = fmt.Sprintf("user_id = ? AND (time >= ? AND time <= ?) AND type=?")
	}

	var incomeCount, expenditureCount int64
	var largestIncome, largestExpenditure moneyM.Transaction
	res := d.Model(&largestIncome).Where(query, u.ID, startDate, endDate, "收入").Order("amount desc").Count(&incomeCount)
	if res.Error != nil {
		bizCtx.DBError(res.Error)
		return
	}
	if incomeCount > 0 {
		if err := res.Take(&largestIncome).Error; err != nil {
			bizCtx.DBError(err)
			return
		}
	}
	res = d.Model(&largestExpenditure).Where(query, u.ID, startDate, endDate, "支出").Order("amount desc").Count(&expenditureCount)
	if res.Error != nil {
		bizCtx.DBError(res.Error)
		return
	}
	if expenditureCount > 0 {
		if err := res.Take(&largestExpenditure).Error; err != nil {
			bizCtx.DBError(err)
			return
		}
	}
	var totalIncome, totalExpenditure float64

	if incomeCount > 0 {
		if err := d.Model(moneyM.Model()).Select("ROUND(SUM(amount),2)").Where(query, u.ID, startDate, endDate, "收入").Scan(&totalIncome).Error; err != nil {
			bizCtx.DBError(err)
			return
		}
	}
	if expenditureCount > 0 {
		if err := d.Model(moneyM.Model()).Select("ROUND(SUM(amount),2)").Where(query, u.ID, startDate, endDate, "支出").Scan(&totalExpenditure).Error; err != nil {
			bizCtx.DBError(err)
			return
		}
	}

	resp := money.TransactionView{
		Count:            incomeCount + expenditureCount,
		IncomeCount:      incomeCount,
		ExpenditureCount: expenditureCount,
		Income:           float32(totalIncome),
		Expenditure:      float32(totalExpenditure),
		Balance:          float32(totalIncome - totalExpenditure),
	}
	if incomeCount > 0 {
		resp.LargestIncome = &money.Transaction{
			ID:       int64(largestIncome.ID),
			Type:     largestIncome.Type,
			Category: largestIncome.Category,
			Amount:   float32(largestIncome.Amount),
			Note:     largestIncome.Note,
			Time:     largestIncome.Time.Unix(),
		}
	}

	if expenditureCount > 0 {
		resp.LargestExpenditure = &money.Transaction{
			ID:       int64(largestExpenditure.ID),
			Type:     largestExpenditure.Type,
			Category: largestExpenditure.Category,
			Amount:   float32(largestExpenditure.Amount),
			Note:     largestExpenditure.Note,
			Time:     largestExpenditure.Time.Unix(),
		}
	}

	bizCtx.Response(&resp)
	mislog.DefaultLogger.Infof("MoneyGetView Success [Name] %s \n", u.Name)
}

// TransactionDelete .
// @router api/money [DELETE]
func TransactionDelete(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	if req.OneTransaction == nil {
		bizCtx.ParmaError(money.ErrTransactionError)
		return
	}
	if req.OneTransaction.ID <= 0 {
		bizCtx.ParmaError(money.ErrTransactionIDError)
		return
	}

	d := db.Get()
	err = d.Transaction(func(tx *gorm.DB) error {
		var transaction moneyM.Transaction
		if err := tx.Where("user_id = ? AND id = ? ", u.ID, req.OneTransaction.ID).First(&transaction).Error; err != nil {
			return err
		}
		if err := tx.Where("user_id = ? AND id = ? ", u.ID, req.OneTransaction.ID).Delete(moneyM.Model()).Error; err != nil {
			return err
		}
		personal := moneyM.TransactionPersonal{}
		if err := personal.UpdateDelete(tx, transaction); err != nil {
			return err
		}
		return nil

	})
	if err != nil {
		bizCtx.DBError(err)
		return
	}

	bizCtx.Success()
	mislog.DefaultLogger.Infof("MoneyDelete Success [Name] %s [DeleteID] %d \n", u.Name, req.OneTransaction.ID)

}

// TransactionContent .
// @router api/money/content [POST]
func TransactionContent(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionContentReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	req.Content = strings.TrimSpace(req.Content)
	if req.Content == "" {
		bizCtx.ParmaError(money.ErrContentEmptyError)
		return
	}

	result := money.DefaultTransactionParser.Parse(req.Content)
	if len(result) <= 0 {
		bizCtx.ParmaError(money.ErrParserError)
		return
	}
	resp := money.TransactionResp{
		Transactions: result,
	}

	bizCtx.Response(&resp)
	mislog.DefaultLogger.Infof("MoneyContent Success [Name] %s [ParserCount] %d \n", u.Name, len(result))
}

// TransactionGetPersonalView .
// @router api/money/personal [POST]
func TransactionGetPersonalView(ctx context.Context, c *app.RequestContext) {
	bizCtx := request.NewBizContext(c)
	var err error
	var req money.TransactionGetReq
	err = c.BindAndValidate(&req)
	if err != nil {
		bizCtx.ParmaError(err)
		return
	}
	u, ok := user.ExtractUser(ctx)
	if !ok {
		bizCtx.ParmaError(base.UIDError)
		return
	}
	entry := moneyM.TransactionPersonal{}
	d := db.Get()
	res := d.Where("user_id = ?", u.ID).Find(&entry)
	if res.Error != nil {
		bizCtx.DBError(res.Error)
		return
	}
	resp := money.TransactionPersonalView{
		Count:            entry.Count,
		IncomeCount:      entry.IncomeCount,
		ExpenditureCount: entry.ExpenditureCount,
		Income:           float32(math.Round(float64(entry.Income)*100) / 100),
		Expenditure:      float32(math.Round(float64(entry.Expenditure)*100) / 100),
		Balance:          float32(math.Round(float64(entry.Balance)*100) / 100),
		StartTime:        entry.StartTime.Unix(),
	}

	bizCtx.Response(&resp)

	mislog.DefaultLogger.Infof("MoneyGetPersonalView Success [Name] %s \n", u.Name)
}
